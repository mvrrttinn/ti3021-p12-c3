# Conectarnos a la base de datos
import oracledb
# Rescatar variables de entorno
import os
from dotenv import load_dotenv
# Implementar hasheo de contrasenas
import bcrypt
# Importar el tipo de dato Opcional
from typing import Optional
# Implementar peticiones HTTP
import requests
# Importar liberia de fechas
import datetime
# Importar sistema para salir en caso de error critico
import sys

# Cargar las variables desde el archivo .env
load_dotenv()
# Rescatar las credenciales de conexion con Oracle
username = os.getenv("ORACLE_USER")
dsn = os.getenv("ORACLE_DSN")
password = os.getenv("ORACLE_PASSWORD")

class Database:
    def __init__(self, username, password, dsn):
        self.username = username
        self.password = password
        self.dsn = dsn

    def get_connection(self):
        # Manejo de la conexion para reportar errores
        try:
            return oracledb.connect(user=self.username, password=self.password, dsn=self.dsn)
        except oracledb.DatabaseError as error:
            print(f"\n--- ERROR DE CONEXION A LA BASE DE DATOS ---")
            print(f"Verifique sus credenciales o el estado de la base de datos.")
            print(f"Detalle: {error}")
            sys.exit(1) # Terminar el programa si no hay conexion

    def create_all_tables(self):
        print("Intentando crear tablas si no existen...")
        # Creacion de la tabla USERS
        self.query("""
            CREATE TABLE USERS (
                id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
                username VARCHAR2(50) NOT NULL UNIQUE,
                password_hash VARCHAR2(100) NOT NULL,
                CONSTRAINT users_pk PRIMARY KEY (id)
            )
        """)
        # Creacion de la tabla INDICATOR_LOG
        self.query("""
            CREATE TABLE INDICATOR_LOG (
                log_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
                indicator_name VARCHAR2(50) NOT NULL,
                indicator_value NUMBER,
                value_date DATE NOT NULL,
                query_date DATE NOT NULL,
                username_query VARCHAR2(50) NOT NULL,
                source_site VARCHAR2(100) NOT NULL,
                CONSTRAINT log_pk PRIMARY KEY (log_id)
            )
        """)
        print("Tablas verificadas/creadas.")


    def query(self, sentence: str, parameters: Optional[dict] = None, fetch_data: bool = False):
        #print(f"Ejecutando query:\n{sentence}\nParametros:\n{parameters}")
        try:
            with self.get_connection() as connection:
                with connection.cursor() as cursor:
                    cursor.execute(sentence, parameters or {})
                    if fetch_data:
                        # Si se requiere traer datos (ej. SELECT), retornamos el resultado
                        return cursor.fetchall()
                    else:
                        # Si es un INSERT, UPDATE, DELETE o CREATE TABLE, hacemos commit
                        connection.commit()
                        return None # No hay resultado que retornar
        except oracledb.DatabaseError as error:
            # Oracle ya maneja la reversion automatica de la transaccion en caso de error
            if "ORA-00955" in str(error): # Error especifico de tabla ya existente
                return None
            print(f"\n--- ERROR EN BASE DE DATOS ---")
            print(f"Query: {sentence}")
            print(f"Detalle: {error}")
            return None


# Generar autenticacion
class Auth:
    @staticmethod
    def register(db: Database, username: str, password: str) -> bool:
        # Validacion simple contra ataques de inyeccion (aunque el uso de binds previene la inyeccion SQL)
        if not (username and password):
             print("\nERROR: Nombre de usuario o contrasena no pueden estar vacios.")
             return False

        try:
            # Generamos el hash con la sal incluida (bcrypt lo gestiona internamente)
            password_bytes = password.encode('utf-8')
            hashed_password = bcrypt.hashpw(password_bytes, bcrypt.gensalt(12))
            
            # Usando la propiedad de bind variables de Oracle para prevenir SQL Injection
            db.query(
                "INSERT INTO USERS (username, password_hash) VALUES (:username, :password_hash)",
                {
                    "username": username,
                    "password_hash": hashed_password.decode('utf-8') # Decodificamos a string para guardar en VARCHAR2
                }
            )
            print(f"\nUsuario '{username}' registrado exitosamente.")
            return True
        except oracledb.DatabaseError as error:
            if "unique constraint" in str(error).lower():
                print(f"\nERROR: El nombre de usuario '{username}' ya existe.")
            else:
                print(f"\nERROR al registrar el usuario: {error}")
            return False

    @staticmethod
    def get_user_by_username(db: Database, username: str) -> Optional[tuple]:
        # Usamos query con fetch_data=True para SELECT
        resultado = db.query(
            "SELECT id, username, password_hash FROM USERS WHERE username = :username",
            {"username" : username},
            fetch_data=True
        )
        # resultado es una lista de tuplas. Si esta vacio, no existe el usuario.
        if resultado:
            return resultado[0] # Retorna la tupla del usuario
        return None

    @staticmethod
    def login(db: Database, username: str, password: str) -> bool:
        user_data = Auth.get_user_by_username(db, username)

        if user_data:
            # user_data[2] contiene el password_hash
            password_hash_db = user_data[2].encode('utf-8') # Convertimos el hash a bytes
            password_input_bytes = password.encode('utf-8') # Convertimos la contrasena de entrada a bytes

            # Comparamos la contrasena de entrada con el hash almacenado
            if bcrypt.checkpw(password_input_bytes, password_hash_db):
                print(f"\nÂ¡Bienvenido, {username}!")
                return True
            else:
                print("\nERROR: Contrasena incorrecta.")
                return False
        else:
            print("\nERROR: Nombre de usuario no encontrado.")
            return False


class Finance:
    def __init__(self, base_url: str = "https://mindicador.cl/api"):
        self.base_url = base_url
        self.source_site = "mindicador.cl/api" # Proveedor de la informacion

    def _log_query(self, db: Database, indicator_name: str, value: Optional[float], value_date: str, username: str):
        """Metodo interno para registrar la consulta en la BD."""
        
        # Validaciones de entrada para prevencion
        if not indicator_name or not username:
            print("ERROR: No se puede registrar la consulta, falta indicador o usuario.")
            return
            
        current_date = datetime.datetime.now()

        log_data = {
            "indicator_name": indicator_name,
            "indicator_value": value,
            "value_date": datetime.datetime.strptime(value_date, "%Y-%m-%d"), # Convertir string a objeto fecha
            "query_date": current_date,
            "username_query": username,
            "source_site": self.source_site
        }

        db.query(
            """
            INSERT INTO INDICATOR_LOG (indicator_name, indicator_value, value_date, query_date, username_query, source_site)
            VALUES (:indicator_name, :indicator_value, :value_date, :query_date, :username_query, :source_site)
            """,
            log_data
        )
        #print("Consulta registrada en la base de datos.") # Descomentar para debug


    def get_indicator(self, db: Database, username: str, indicator: str = None):
        if not indicator:
            return print("Indicador faltante")
            
        # Validaciones de entrada para prevencion
        if indicator not in ["uf", "ivp", "ipc", "utm", "dolar", "euro"]:
            print(f"ERROR: El indicador '{indicator}' no es valido.")
            return None

        url = f"{self.base_url}"
        try:
            response = requests.get(url=url, timeout=10) # Anadir timeout para robustez
            response.raise_for_status() # Lanza excepcion para codigos de error HTTP
            data = response.json()
        except requests.exceptions.RequestException as e:
            print(f"ERROR al obtener datos de la API: {e}")
            self._log_query(db, indicator, None, str(datetime.date.today()), username) # Registrar como fallida
            return None
        
        # Obtenemos el valor directamente del objeto, no de la serie
        if indicator in data:
            indicador_info = data[indicator]
            nombre = indicador_info.get('nombre', indicator)
            valor = indicador_info.get('valor')
            unidad = indicador_info.get('unidad_medida', 'N/A')
            fecha_valor_str = indicador_info.get('fecha', str(datetime.date.today()))[:10] # Obtenemos solo la fecha YYYY-MM-DD
            
            print(f"{nombre} ({fecha_valor_str}): {valor} {unidad}")
            
            # --- Nuevo: Registro de la consulta ---
            self._log_query(db, nombre, valor, fecha_valor_str, username)
            
            return valor
        else:
            print(f"No se encontro el indicador {indicator} en la respuesta de la API.")
            self._log_query(db, indicator, None, str(datetime.date.today()), username) # Registrar como fallida
            return None

    # Modificamos los wrappers para que acepten db y username
    def get_uf(self, db: Database, username: str):
        return self.get_indicator(db, username, "uf") 
    def get_ivp(self, db: Database, username: str):
        return self.get_indicator(db, username, "ivp") 
    def get_ipc(self, db: Database, username: str):
        return self.get_indicator(db, username, "ipc") 
    def get_utm(self, db: Database, username: str):
        return self.get_indicator(db, username, "utm") 
    def get_usd(self, db: Database, username: str):
        return self.get_indicator(db, username, "dolar") 
    def get_eur(self, db: Database, username: str):
        return self.get_indicator(db, username, "euro") 

if __name__ == "__main__":
    db = Database(username, password, dsn)
    db.create_all_tables()
    indicadores = Finance()
    username_logged = None

    # --- Flujo de Autenticacion ---
    while username_logged is None:
        print("""
        ----------------------------------
        |      SISTEMA DE AUTENTICACION  |
        ----------------------------------
        | 1. Iniciar Sesion (Login)      |
        | 2. Registrar Usuario (Register)|
        | 3. Salir                       |
        ----------------------------------
        """)
        auth_opcion = input("Seleccione una opcion (1-3): ")

        if auth_opcion == "1":
            user = input("Ingrese nombre de usuario: ")
            pw = input("Ingrese contrasena: ")
            if Auth.login(db, user, pw):
                username_logged = user
        elif auth_opcion == "2":
            user = input("Ingrese nuevo nombre de usuario: ")
            pw = input("Ingrese nueva contrasena: ")
            Auth.register(db, user, pw)
        elif auth_opcion == "3":
            print("\nSaliendo del sistema.")
            sys.exit(0)
        else:
            print("\nOpcion no valida. Intente de nuevo.")
            
    # --- Menu interactivo (Solo si el usuario esta logueado) ---
    while True:
        print(f"\nUsuario actual: {username_logged}")
        print("""
        -----------------------------------------------
        |    MENU DE INDICADORES - VALORES CHILENOS    |
        -----------------------------------------------  
        | 1. Unidad de Fomento (UF)                    |
        | 2. Indice de Valor Promedio (IVP)            | 
        | 3. Indice de Precios al Consumidor % (IPC)   | 
        | 4. Unidad Tributaria Mensual (UTM)           | 
        | 5. Dolar a peso chileno (CLP)                | 
        | 6. Euro a peso chileno (CLP)                 | 
        | 7. Salir del consultor                       |
        ----------------------------------------------- 
        """)
        opcion = input("Seleccione una opcion (1-7): ")
        
        # Pasamos la instancia de db y el nombre de usuario logueado a las funciones
        if opcion == "1":
            indicadores.get_uf(db, username_logged)
        elif opcion == "2":
            indicadores.get_ivp(db, username_logged)
        elif opcion == "3":
            indicadores.get_ipc(db, username_logged)
        elif opcion == "4":
            indicadores.get_utm(db, username_logged)
        elif opcion == "5":
            indicadores.get_usd(db, username_logged)
        elif opcion == "6":
            indicadores.get_eur(db, username_logged)
        elif opcion == "7":
            print("\nHasta luego, gracias por usar el consultor de indicadores.")
            break
        else:
            print("\n Opcion no valida. Por favor ingrese un numero del 1 al 7....")
        
        

